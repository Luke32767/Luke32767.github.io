---
layout: post
title: '[NOIP2002 普及组] 过河卒'
author: Luke32767
date: 2022-10-14 22:24 +0800
last_modified_at: 2022-10-14 22:24 +0800
tags: [NOIP, Luogu]
toc: true
---
## 内容概要
[NOIP2022 普及组 第4题] 过河卒

## 题目描述
棋盘上A点有一个过河卒，需要走到目标B点。卒行走的规则：可以向下、或者向右。同时在棋盘上C点有一个对方的马，该马所在的点和所有跳跃一步可达的点称为对方马的控制点。因此称之为“马拦过河卒”。

棋盘用坐标表示，A 点 (0, 0) 、 B 点 (n, m) ，同样马的位置坐标是需要给出的。

![](https://cdn.luogu.com.cn/upload/image_hosting/vg6k477j.png)

现在要求你计算出卒从A点能够到达B点的路径的条数，假设马的位置是固定不动的，并不是卒走一步马走一步。

## 输入格式

一行四个正整数，分别表示B点坐标和马的坐标。

## 输出格式

一个整数，表示所有的路径条数。

## 题目说明

[NOIP2022 普及组 第4题] 过河卒

对于100%的数据 1 ≤ n,m ≤ 20，0 ≤ 马的坐标 ≤ 20。

## 题目样例

### 样例输入 #1

```
6 6 3 3
```

### 样例输出 #1

```
6
```

## 题目解答

``` c++
//P1002
#include <bits/stdc++.h>

using namespace std;

long long f[25][25];
bool g[25][25];

int main()
{
	int x1, y1, x2, y2; 

	scanf("%d %d", &x1, &y1);
	scanf("%d %d", &x2, &y2);

	g[x2][y2] = 1;

	if(x2 > 1 and y2 != 0)   g[x2 - 2][y2 - 1] = 1;
	if(x2 < 19 and y2 != 0)  g[x2 + 2][y2 - 1] = 1;
	if(x2 > 1 and y2 != 20)  g[x2 - 2][y2 + 1] = 1;
	if(x2 < 19 and y2 != 20) g[x2 + 2][y2 + 1] = 1;
	if(x2 != 0 and y2 > 1)   g[x2 - 1][y2 - 2] = 1;
	if(x2 != 0 and y2 < 19)  g[x2 - 1][y2 + 2] = 1;
	if(x2 != 20 and y2 > 1)  g[x2 + 1][y2 - 2] = 1;
	if(x2 != 20 and y2 < 19) g[x2 + 1][y2 + 2] = 1;

	for(int i = 0; i <= x1; ++i) 
		for(int j = 0; j <= y1; ++j) 
			if(!g[i][j]) {
				if(i == 0 and j == 0)
					f[0][0] = 1;
				else if(i == 0 and j > 0)
					f[0][j] = f[0][j - 1];
				else if(i > 0 and j == 0)
					f[i][0] = f[i - 1][0];
				else
					f[i][j] = f[i - 1][j] + f[i][j - 1];
			}
	
	printf("%lld\n", f[x1][y1]);

	return 0;
}
```
